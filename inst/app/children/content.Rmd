```{r context="server"}

assignment_accessible = reactive({
    
  req(assignment())

  assignment = assignment()
  assignment_data = all_assignment_data[[assignment]]
  
  assignment_data$restrict_before<Sys.time()
  
})

```

```{r context="server"}
init_list = reactive({
  
  req(assignment(), isolate(validSeed()), entry())

  assignment = assignment()
  assignment_data = all_assignment_data[[assignment]]
  
  fmt = flexTeaching::pkg_options()$date_format_prnt
  
  validate(
    need(assignment_accessible(), 
         glue::glue("This assignment will not be available until {strftime(assignment_data$restrict_before, format = fmt)}."))
  )
  
  validate(
    need(!assignment_data$exam || entry() != "solve" || seedMatches(), 
          "This assignment is not available in practice mode."
         )
  )

  id = input$id
  seed = seed()
  solutions = solutions()

  salt = assignment_data$`data-salt`
  seed0 = flexTeaching:::assignmentSeed(id, seed, salt)
  
  # Make parent .GlobelEnv so that apps will not have access to shiny
  # variables; prevents some sneaky hacks like entering R code into
  # text inputs
  e = new.env(parent = .GlobalEnv)
  
  flexTeaching:::sourceAll(assignment_data, e)
  
  if(!is.null(assignment_data$init)){
    init_func = get(assignment_data$init, envir = e)
    R.utils::withSeed({
      ret_list = init_func(assignment_data, id, seed, solutions, e)
    },
    seed0)
  }else{
    ret_list = list()
  }
    
  return(ret_list)
    
}) %>% bindCache(assignment(), input$id, seed(), solutions(), assignment_accessible(), entry(), seedMatches())
```


```{r context="render"}
uiOutput("buttonBox", style = "width: 100%; margin: auto;")
```

```{r context="server"}

output$buttonBox <- renderUI({
  
  req(assignment(), entry())
  
  assignment = assignment()
  assignment_data = all_assignment_data[[assignment]]
  
  req(
    assignment_accessible(),
    !assignment_data$exam || entry() != "solve" || seedMatches()
    )
  
  solutions = solutions()
  
  # Make parent .GlobelEnv so that apps will not have access to shiny
  # variables; prevents some sneaky hacks like entering R code into
  # text inputs
  e = new.env(parent = .GlobalEnv)
  
  flexTeaching:::sourceAll(assignment_data, e)
  
  bn = assignment_data$buttons

  req(
    !is.null(bn),
    exists(bn, envir = e)
    )
  
  bs = get(bn, envir = e)
  
  button_reactives = list()
  
  bl = lapply(names(bs), function(b){
    button_reactives[[b]] = reactive({
      shinybusy::show_modal_spinner(text = "Creating file...")
      fc = try(
        {
          bs[[b]]$f(
            assignment_data,
            input$id,
            seed(),
            solutions,
            input$format,
            init_list(),
            entry()
            )
        })
      shinybusy::remove_modal_spinner()
      if(inherits(fc, "try-error")){
        err_text = glue::glue("There was an error creating the file. {paste(fc)}")
        shinyWidgets::sendSweetAlert(
          session = session,
          title = "Error...",
          text = err_text,
          type = "error"
        )
        ## There doesn't seem to be a good way of cancelling a download.
        ## See: https://github.com/rstudio/shiny/issues/2611
        stop(err_text)
      }else{
        return(fc)
      }    }) %>% bindCache(assignment(), input$id, seed(), solutions(), input$format, b, assignment_accessible(), entry(), seedMatches())
    
    output[[glue::glue("button_{b}")]] <- downloadHandler(
      filename = function() {
        button_reactives[[b]]()$fn
      },
      content = function(f) {
        d = button_reactives[[b]]()$d
        con = file(description = f, open = "wb")
        writeBin(object = d, con = con)
        close(con)
      }
    )
    
    shiny::downloadButton(glue::glue("button_{b}"), label=bs[[b]]$label,
                          icon = icon(bs[[b]]$icon))
  })
  
  do.call(tagList, bl)
})
```



### Assignment

```{r context="render"}
uiOutput("assignmentBox")
```

```{r context="server"}
render_out <- reactive({
  
  req(assignment(), isolate(validSeed()), entry())
  assignment = assignment()
  assignment_data = all_assignment_data[[assignment]]
  
  id = input$id
  seed = seed()
  solutions = solutions()
  
  i = init_list()
  
  e = new.env(parent = .GlobalEnv)
  flexTeaching:::sourceAll(assignment_data, e)
  
  html = flexTeaching:::compilePage(assignment_data, id, seed, solutions, e, i)
  
 return(html)
  
}) %>%
  bindCache(assignment(), input$id, seed(), solutions(), assignment_accessible(), entry(), seedMatches())
```

```{r context="server"}
output$assignmentBox <- renderUI({
  withMathJax(render_out())
})
```


```{r context="server"}
observeEvent(render_out(), {
  
  req(assignment(), isolate(validSeed()), entry())
  assignment = assignment()
  assignment_data = all_assignment_data[[assignment]]
  
  req(
    assignment_accessible(),
    !assignment_data$exam || entry() != "solve" || seedMatches()
  )
  # Identicon
  id = input$id
  seed = seed()
  salt = assignment_data$`data-salt`
  seed0 = flexTeaching:::assignmentSeed(id, seed, salt)
  shinyjs::runjs(glue::glue("jdenticon.updateSvg('#flexteaching-fingerprint', '{seed0}');"))

  # Loading javascript
  req(!is.null(assignment_data[['on-load']]))
  
  js_content = gsub(pattern = "\"", replacement = "\\\"", x = assignment_data[['on-load']],
                    fixed = TRUE)
  
  e = new.env(parent = .GlobalEnv)
  e$.flexteach_info = init_list()
  js_expr = parse(text = glue::glue('glue::glue("{js_content}")'))
  
  js_parsed = tryCatch(eval(expr = js_expr, envir = e),
    error = function(c){
      # Using paste0 instead of glue to prevent code injection from input
      error_text = paste0(
        "Problem parsing javascript code on load of assignment ",
        assignment(),
        ": ",
        c
      )
      safeError(error_text)
    }
  )

  if(!is.null(js_parsed) & length(js_parsed)>0)
    shinyjs::runjs(js_parsed)
  
})
```
